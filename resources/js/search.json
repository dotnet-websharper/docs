[[{"l":"Welcome","p":["✅ Your website is working.","but... this is a placeholder Welcome page.","To replace this placeholder page, create a readme.md file and add it to the root of your project.","You can name the file index.md, default.md, readme.md, or welcome.md."]},{"l":"Settings","p":["Check out the following Project settings to customize your website."]},{"l":"Set the project name","p":["Customize your Project Name by setting the title in your retype.yml file:","Or, use your logo:","Create a /static folder and then add a copy of your-logo.png file to that new folder. You can name the folder and file whatever you want, such as /images/my-logo.png."]},{"l":"Set the URL","p":["Improve your website Search Engine Optimization (SEO) by setting the url in your retype.yml file:"]},{"l":"Add top links","p":["Add custom links to the top navigation:"]},{"l":"Help","p":["Need some help with Retype?","A live support person is generally available on chat on the retype.com website.","If you find a defect or would like to submit a feature request, please create an Issue and we will investigate right away.","Do you have a general inquiry? Please feel free to contact us at hello@retype.com.","We ❤️ your feedback."]}],[{"l":"Basics","p":["This page is not yet written, please check back soon!"]}],[{"l":"Prerequisites","p":["WebSharper applications are ASP.NET Core applications, and to develop and build them you pretty much only need a .NET SDK. However, we also recommend you install the WebSharper CLI, your favorite IDE with F# support, and the Azure SDK and CLI:"]},{"i":"net-sdk","l":".NET SDK","p":[". NET 6.0.100 SDK or higher, available from https://dotnet.microsoft.com/download. The SDK contains the dotnet CLI tool that you can use to install WebSharper project templates, compile and run projects, and prepare deployment packages.","WebSharper 7 (upcoming) will target net70.","WebSharper 5/6 applications target net50/ net60, respectively.","If you need to target .NET Framework 4.x ( net472, etc.), you must use WebSharper 4.x."]},{"l":"WebSharper CLI","p":["The WebSharper CLI is a dotnet tool that helps streamline building applications and manage compiler runtimes.","You can install it using dotnet:"]},{"l":"IDE","p":["You need an IDE to work with WebSharper projects effectively. We recommend one of the following:","Visual Studio Community or above, available from https://visualstudio.microsoft.com.","Visual Studio Code, available from https://code.visualstudio.com. For F# support, you can use:","the Ionide plugin, installed through the Extensions tab and searching for \"Ionide\", or via a direct download from https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp.","You can also use Rider, emacs or vi with F# support, or any other IDE of your choice, but you need to make sure they are properly configured for compiling, running and debugging F#/WebSharper projects."]},{"l":"Cloud tools","p":["Azure SDK- to work with the az CLI tool to deploy your WebSharper applications to Azure."]}],[{"l":"NuGet packages","p":["WebSharper uses NuGet packages to ship the core tools(the F#/C# to JS compilers, build automation, etc.) - often just referred to as WebSharper, proxies for the F# standard library and other .NET libraries, and bindings(also called \"extensions\") to JavaScript libraries. This makes it easy and predictable to add or update various WebSharper components in your applications."]},{"l":"Configuring the WebSharper developer feed","p":["WebSharper and its components are available on NuGet.org. In addition, if you would also like to access the latest developer packages, you can find them on the WebSharper GitHub packages feed at https://nuget.pkg.github.com/dotnet-websharper/index.json:","The standard NuGet feed should come configured on your system when installing the .NET SDK. If you want to configure the WebSharper GitHub feed as well, you can do so as follows:","where GH_USER is your GitHub username, and PAT is your Personal Access Token (PAT) for your GitHub account.","At the time of writing, GitHub requires authentication to access packages on its Packages feed. To set your access up, create a new PAT at https://github.com/settings/tokens/new with the read:packages scope, noting the expiration you configure.","If your project uses Paket, you will need to configure the above GitHub feed for Paket as well:"]},{"l":"Core NuGet packages","p":["A charting library with a similar API to FSharp.Charting and configurable renderers.","A client-side testing framework for WebSharper.","A highly performant, reactive UI library with type-safe templating. The recommended way to deal with reactive HTML.","A reactive forms library built on top of WebSharper.UI, with support for declarative, composable web forms with retargetable rendering.","Below are some of the WebSharper NuGet packages that you will be working with:","Helpers to use WebSharper from an ASP.NET Core project. You only usually need it for your web projects, not libraries (unless the library builds on some ANC functionality.)","msbuild targets/build automation to light up WebSharper features, including the main F# to JavaScript compiler.","Package name","Same as WebSharper.FSharp, except for C#.","The core package for any WebSharper project. Includes proxies for the F# standard library, the core JavaScript bindings for DOM, EcmaScript, etc., the sitelets runtime with remoting and static server-side content generation, and the WebSharper Interface Generator (WIG) for creating your own JavaScript bindings. Reference it in any WebSharper project/library, along with WebSharper.FSharp or WebSharper.CSharp, depending on your source language.","The WebSharper project templates for F# and C#.","WebSharper","WebSharper.AspNetCore","WebSharper.Charting","WebSharper.CSharp","WebSharper.Forms","WebSharper.FSharp","WebSharper.Templates","WebSharper.Testing","WebSharper.UI","What does it provide?"]},{"l":"Compiler packages","p":["For more advanced use cases, where you need custom JavaScript compilation, you can use the following packages:","Package name","What does it provide?","WebSharper.Compiler.Common","Core WebSharper compiler utilities shared by the F# and C# to JavaScript compilers, including offline sitelet generation.","WebSharper.Compiler.FSharp","The F# to JavaScript compiler. Depends on WebSharper.Compiler.Common and FSharp.Compiler.Services.","WebSharper.Compiler.CSharp","The C# to JavaScript compiler. Depends on WebSharper.Compiler.Common and Microsoft.CodeAnalysis.CSharp(a.k.a. Roslyn).","WebSharper.Compiler","Includes both WebSharper.Compiler.FSharp and WebSharper.Compiler.CSharp."]}],[{"i":"net-project-templates-for-websharper","l":".NET project templates for WebSharper","p":["You may also want to configure the WebSharper GitHub feed, containing experimental tools and developer builds. To do so, make sure you have this extra feed configured.","You can install the latest WebSharper project templates via the dotnet CLI - this will also make them available in Visual Studio 2022 and above. As of WebSharper 6, no separate VSIX installer is available, so use the following command to install:","You can also install any given version by adding the version as a suffix, for instance ::6.0.0.140.","Different WebSharper project templates are available for F# and C#. You can set the language of your preference in your shell with:","To see what project templates are installed on your system and what's the default language for each, you can use:"]},{"i":"how-to-decide-what-template-to-use","l":"How to decide what template to use?","p":["Here are some guidelines on choosing the right project for your app:"]},{"i":"does-your-application-have-a-server-side","l":"Does your application have a server-side?","p":["Yes -> use the client-server application template ( websharper-web) for microservices or full-stack apps. If you have a single page with possibly multiple sub-pages, use the single-page application template ( websharper-spa).","No, I need to build a static web app and host it with my own web host (GitHub Pages, etc.) -> use the HTML application ( websharper-html), or the single-page application template ( websharper-spa) without a server-side."]},{"i":"whats-the-difference-between-an-html-application-and-an-spa","l":"What's the difference between an HTML application and an SPA?","p":["An HTML application can contain multiple pages and has no server-side (RPCs or websockets, but it can still make requests to external services). An SPA has a single containing page with possibly multiple sub-pages inside it, and it may have an optional server-side."]},{"i":"can-i-have-multiple-containing-pages-in-an-spa","l":"Can I have multiple containing pages in an SPA?","p":["Yes, but each page needs to be a separate SPA project and you need to manually assemble them into a single app by copying all master pages and their generated JavaScript code and other artifacts."]},{"i":"i-want-to-use-our-legacy-javascript-codebase-and-other-third-party-javascript-libraries-in-my-application","l":"I want to use our legacy JavaScript codebase and other, third-party JavaScript libraries in my application.","p":["Create a bindings for them using the JavaScript binding template ( websharper-ext). You may also want to look around on NuGet or GitHub to see if a binding already exists."]},{"i":"i-have-net-code-that-fails-to-compile-with-websharper","l":"I have .NET code that fails to compile with WebSharper.","p":["Create a .NET proxy project ( websharper-prx) to describe how to map your .NET code to JavaScript."]},{"i":"i-want-to-package-up-some-of-my-ui-andor-client-side-logic-to-be-shared-with-other-websharper-applications","l":"I want to package up some of my UI and/or client-side logic to be shared with other WebSharper applications.","p":["Create a WebSharper library ( websharper-lib)."]},{"l":"Quick overview of the available templates"},{"l":"Minimal Application","p":["websharper-min creates a minimal server-side application that you can expand into a full-stack web application. It contains the boilerplate to create a sitelet that responds with a simple text response. Check the Hello world! example for more information."]},{"l":"Single-Page Application","p":["websharper-spa creates a single-page application (SPA) with a master index.html file, into which dynamic client-side functionality is injected. You can expand this template with an optional server-side by adding RPCs to it."]},{"l":"Client-Server Application","p":["websharper-web creates a full-stack client-server application. Use this as a base for your full-stack applications.","The rest of the page is not yet written, please check back soon!"]}],[{"l":"Creating a new WebSharper project from scratch","p":["If you don't have the WebSharper project templates installed and need a basic, server-only setup to experiment with (the equivalent of the websharper-min project template), you can create it as follows:","Create an empty F# ASP.NET Core project","Add the WebSharper and WebSharper.AspNetCore packages to it:","Add Site.fs to the project with the following content:","Modify Startup.fs as follows:","Add a WebSharper configuration file for future use:","Run the app with dotnet run."]}],[{"l":"Compilation speed","p":["This page is not yet written, please check back soon!"]}],[{"l":"Debugging your client-side with source maps","p":["Source maps enable mapping transpiled JavaScript code back to the original source files that produced it. With source maps, you can debug your applications and use breakpoints in them using your original source files inside your browser.","When you enable source maps in a project, your F# source files will be bundled into it. Therefore, it is strongly advised that you disable source maps in release mode."]},{"l":"Embedding source maps in WebSharper libraries","p":["You can enable generating source maps and bundling your source files in a WebSharper assembly by adding sourceMap: true to the project's wsconfig.json:","Alternatively, you can add also the WebSharperSourceMap property to your project file:","WebSharper itself is built with source maps, so you can debug into WebSharper library code as well as your user code.","Source maps are supported in full-stack applications, single-page applications (SPAs), and static HTML+JavaScript applications (offline sitelets)."]},{"l":"Usage","p":["Next to enabling source maps in your application project, you need to enable working with source maps in your browser as well."]},{"i":"google-chrome--microsoft-edge-chromium","l":"Google Chrome & Microsoft Edge Chromium","p":["Press Ctrl + Shift + I to open Developer Tools, click on the cog icon to bring up Settings, and check the \"Enable JavaScript source maps\" setting.","In the Sources tab, open the Scripts/WebSharper folder to load the available source mappings. A folder named Source will appear with the original .fs files. You can open these files and set breakpoints in them just like in your IDE.","Chrome source mapping"]},{"l":"Mozilla Firefox","p":["To enable source maps, press Ctrl + Shift + I to open the Web Developer Tools, then press F1 for Settings, and check the \"Enable Source Maps\" item in the \"Advanced Settings\" section.","In the Debugger tab of Web Developer Tools, open the Scripts/WebSharper folder to load the source mappings. A folder named Source will appear with the original .fs files.","You can access the original sources, however, breakpoints don't work correctly as of version 108.0.1."]},{"i":"internet-explorer--microsoft-edge-legacy","l":"Internet Explorer & Microsoft Edge Legacy","p":["You need to have Internet Explorer 11 on Windows 8.1 Update 1, or newer, for source map support. Edge has inherited the debugging tool from IE11, and works similarly.","In the Debugger tab of F12 tools, the last icon in the toolbar says \"Load the sources mapped to this generated file\". Use this to jump between generated and original source code. You can set breakpoints in the original code.","IE source mapping"]},{"l":"Outputting source maps for WebSharper web projects","p":["If you have a separate web project hosting your WebSharper application, add the same WebSharperSourceMap property to the project file to unpack the source map files."]}],[{"l":"Getting started with WebSharper","p":["The following examples demonstrate key concepts that help you get up to speed with WebSharper. You can use these as a roadmap to learn the fundamentals of WebSharper, before going into the rest of the documentation.","Hello world- a simple web application that responds \"Hello World\". Learn how to return different content, such as files, JSON, or error codes from your sitelet endpoints.","Single-page applications- learn how to reduce/eliminate HTML from your F# code using strongly-typed, isomorphic templating."]}],[{"i":"hello-world","l":"Hello world!","p":["Here is a simple sitelet that returns \"Hello world!\":","This sitelet has only one entry point: the root of the web application (at /, and the port is configurable). Requests to any other URL yield a 404 error. Given the root as a fixed, single endpoint and the textual response type, Application.Text is quick and easy way to create a simple, highly specialized sitelet when you need to respond with text."]},{"l":"Steps","p":["Install the WebSharper project templates and create a new WebSharper minimal application:","OR","Follow the steps in Creating a new WebSharper project from scratch. Subsequent examples will assume you have installed the WebSharper project templates, instead of going from an empty project.","Run it:"]},{"l":"Going further"},{"l":"Other server responses","p":["You can also construct a multitude of server responses, such as HTML (with or without client-side functionality), JSON data, or serving files; see sitelet responses for more information."]},{"l":"Switching to larger sitelets","p":["Unless you are planning on returning text only, Application.Text is of limited use. You will find Application.SinglePage(see the Single-page application example) and Application.MultiPage(an alias for Sitelet.Infer, see the Full-stack application example) more useful."]}],[{"l":"Single-page applications","p":["Single-page applications (SPAs), as their name suggests, are contained in a single HTML page. Most typically, this single HTML page will be your own index.html file. SPAs can be fully client-side, or more often, call server-side functions for fetching and saving data, and other chores.","Below is an example of using index.html with an id=main placeholder, and injecting a client-side recommended book listing \"widget\" into it, one that receives book titles via an initial RPC call. Although you could use F# code for HTML, the book listing itself is defined as an HTML template named ShowMeBooks inside index.html, with further nested templates for the individual books. This has the added benefit that changes to either template can be dynamically loaded and do not require recompilation (and thus, are nearly instantly applied.)","Using WebSharper.UI templating, your code will only compile if it uses the template correctly. This type safety is paramount and greatly enhances productivity, and coupled with the ability to load template changes dynamically (which is also available in server-side use, via an additional argument; for instance, ServerLoad.WhenChanged) it supercharges and streamlines your developer experience. Practically speaking, once you have an initial HTML skeleton design, you can fully write your application logic against it, compile it with static type-safety guarantees, and then take iterations with sub-second processing time to enhance/perfect the presentation layer."]},{"l":"Steps","p":["Create a new WebSharper SPA:","Replace Client.fs and wwwroot/index.html with the code above.","Run it:","See it in action:"]},{"l":"Going further"},{"l":"Adding a data model","p":["The SPA above doesn't have a client-side data model, for instance, it doesn't keep track of the books added to the cart, nor does it have the capability to refresh the list of recommended books. To add these more realistic features, you can use WebSharper.MVU for a variant of the Model-View-Update (MVU) pattern along with lenses, WebSharper.UI's composite data models(as shown in the websharper-spa project template), or simple reactive variables and their views."]},{"l":"Serving your SPA from a sitelet endpoint","p":["You can also serve/return an SPA from a sitelet endpoint. To convert the above SPA into a sitelet response, you need to make a few minor adjustments to it (removing the Doc.RunById call from Client.Main, adding a ws-hole=Main attribute at the end of your div id=main .. node, and replacing the hardwired SPA.min.js include with div ws-replace=scripts/div to let the sitelet runtime manage your page dependencies). You can then expose the adjusted SPA code from a sitelet:","You can also use Application.MultiPage(aka Sitelet.Infer) and a discriminated union (DU) endpoint type depending on your server-side routing needs."]},{"l":"Client-side vs. server-side routing","p":["And last, true SPAs often model multiple \"logical\" pages inside the single HTML page they are contained in. See WebSharper.MVU for basic support for partitioning your SPA into such pages, or simply use client-side routing and a discriminated union endpoint type to represent them. You can also find more valuable insights in the F# Advent 2017 blog article titled \"Serving SPAs\", especially around splitting your endpoint type into a client-side and server-side part, giving you fine control over where page requests get handled, essentially, transitioning you into full-fledge full-stack application development."]}],[{"i":"websharper-cli---dotnet-ws","l":"WebSharper CLI - dotnet ws","p":["The WebSharper CLI, a recent addition to the WebSharper toolset, aims to streamline common WebSharper tasks/chores with a simple command-line interface via a .NET tool called dotnet-ws. Currently, this covers the following:","Managing WebSharper Booster runtimes/instances. For each version of WebSharper you use in your projects, by default, a Booster instance will be allocated to enhance the compiler's performance. Sometimes, you might need to interact with these instances, such as listing, starting or stopping them.","Building WebSharper projects with no configuration changes. Most of the time you recompile, the compilation context (references, target runtime, etc.) are unchanged and going with the ordinary dotnet build performs unnecessary steps. In these cases, and in certain project types, you can use the WebSharper CLI to compile your projects faster. See the compilation speed page for more details."]},{"i":"where-is-it","l":"Where is it?","p":["Sources: https://github.com/dotnet-websharper/ws-tool","NuGet:"]},{"l":"Installation","p":["You can install the WebSharper CLI via dotnet install:","Specifying -g will make the tool available globally on your machine, and this is recommended. Once you have it installed, you can invoke it with dotnet ws."]},{"l":"Available commands"},{"l":"Managing WebSharper Booster instances","p":["The WebSharper Booster is started as a standalone service called wsfscservice.exe when you first compile a WebSharper project, unless you specifically turn the Booster off in that project.","If you need to turn the Booster off for a given project, you can do so by setting the following in the project's wsconfig.json:","The Booster manages the runtimes that do the actual compilation work, one runtime per compiler version. If you use different WebSharper compilers (by version) in your various projects, you will notice that the Booster will report a runtime instance for each."]},{"l":"Listing running instances","p":["The rest of this page is not yet written, please check back soon!"]},{"l":"Starting a new instance"},{"l":"Stopping an instance"},{"l":"Building projects"}],[{"l":"WebSharper Booster","p":["This page is not yet written, please check back soon!"]}],[{"i":"#","p":["Construct JSON on the server or the client."]},{"l":"WebSharper JSON","p":["WebSharper.Json provides a convenient and developer-friendly JSON serialization format for F# types (and C# classes) for both client-side and server-side scenarios. The JSON structure is automatically inferred from the types involved and can be further customized using attributes. See the JSON format page for more details."]},{"i":"where-is-it","l":"Where is it?","p":["NuGet package: WebSharper","DLL: WebSharper.Main.dll","Namespace: WebSharper.Json"]},{"l":"Using JSON on the server","p":["The WebSharper.Json module provides F# value de/serialization for server-side use via Serialize and Deserialize:"]},{"l":"Serialize","p":["Serialize : 'T - string serializes a value to string."]},{"l":"Deserialize","p":["Deserialize'T : string - 'T deserializes a value from a string. You can pass the desired output type as a type parameter."]},{"l":"JSON in sitelets","p":["WebSharper sitelets provide facilities both to parse JSON payloads from HTTP requests and to return JSON as HTTP responses, greatly reducing the effort needed to implement microservices and REST-based services, among others. Most typically, JSON is sent as a POST request to an endpoint and returned as response from another.","This can be accomplished by using the [Json] attribute on parts of an endpoint type to enable receiving JSON and parsing it into F#/C# types, and using Content.Json to return a JSON response in the opposite direction.","The following code demonstrates both:"]},{"l":"Using JSON on the client","p":["JSON serialization is also available on the client. WebSharper.Json provides the following functions:"]},{"l":"Parse","p":["Parse : string - obj uses JavaScript's JSON.parse to convert a string to a value (no attribute-based transformations)."]},{"l":"Stringify","p":["Stringify : obj - string uses JavaScript's JSON.stringify to convert a value to a string (no attribute-based transformations)."]},{"l":"Encode","p":["Encode : 'T - obj converts a value to a JavaScript object, such that Json.Stringify (Json.Encode x) = Json.Serialize x."]},{"l":"Decode","p":["Decode : obj - 'T converts a JavaScript object to a value, such that Json.Decode (Json.Parse s) = Json.Deserialize s."]},{"l":"Activate","p":["Activate : obj - 'T parses/activates a JSON object returned by the server. This function is used internally to activate values returned from RPC functions."]}],[{"i":"#","p":["F#/C# to JSON"]},{"l":"JSON format","p":["This page describes how F# values (and C# objects) are converted to JSON by the functions available in WebSharper.Json."]},{"l":"Customization","p":["If you would like to customize the default JSON representation, the following attributes are available (see examples in the sections below):","[Name] to customize field names in F# records and union cases in discriminated unions(DUs).","[NamedUnionCases] to customize the name of the discriminator field that determines which DU shape the value holds.","[Constant] to represent DU cases as constants/literals.","[DateTimeFormat](server-side only) to customize the format used for System.DateTime values.","[System.Serializable] to mark C#/F# classes to be JSON serializable."]},{"l":"Base types","p":["\"A string with some \"content\" inside\"","12","12.34","booleans: bool","Content.Json 12.34","Content.Json 12.34m","Content.Json 12ul","Content.Json 12y","Content.Json A string with some content inside","Content.Json true","decimals: decimal","F#","floats: single, double (float)","Output","signed and unsigned integers: uint8 (byte)/ int8, uint16/ int16, uint32/ int32( int), uint64/ int64","strings: string","The following base types are handled:","true"]},{"l":"Collections","p":["Values of type list'T, 'T[] and Set'T are represented as JSON arrays.","Values of type Mapstring, 'T and System.Collections.Generic.Dictionarystring, 'T are represented as flat JSON objects.","Other Map and Dictionary values are represented as an array of key-value pairs.","F#","Output","Content.Json [|a string; another string|]","[\"a string\", \"another string\"]","Content.Json (Set [a string; another string])","[\"another string\", \"a string\"]","Content.Json (Map [(somekey, 12); (otherkey, 34)])","{\"somekey\": 12, \"otherkey\": 34}","Content.Json (Map [(1, 12); (3, 34)])","[[1, 12], [3, 34]]"]},{"l":"Tuples","p":["Tuples (including struct tuples) are also represented as JSON arrays:","F#","Output","Content.Json (a string, another string)","[\"a string\", \"another string\"]","Content.Json (struct (a string, another string)","[\"another string\", \"a string\"]"]},{"l":"Records","p":["F# records are represented as flat JSON objects. The attribute [Name name] can be used to customize the field name:"]},{"l":"Unions","p":["Union types intended for use in JSON serialization should optimally bear the attribute NamedUnionCases for producing fully readable JSON format. There are two ways to use it, specifying a field name to hold the union case name, or signaling that the case should be inferred from the field names. If no NamedUnionCases is present, a $ field will be used for storing the case index."]},{"l":"Explicit discriminator","p":["With [NamedUnionCases field], the union value is represented as a JSON object with a field called field, whose value is the name of the union case, and as many other fields as the union case has arguments. You can use [Name name] to customize the name of a union case.","Unnamed arguments receive the names Item1, Item2, etc.","Missing the [NamedUnionCases] attribute, the case names would be not stored in a readable form:"]},{"l":"Implicit discriminator","p":["With an argumentless [NamedUnionCases], no extra field is added to determine the union case; instead, it is inferred from the names of the fields present. This means that each case must have at least one mandatory field that no other case in the same type has, or a compile-time error will be thrown."]},{"l":"Record inside union","p":["As a special case, if a union case has a single, unnamed record argument, then the fields of this record are used as the fields of the output object."]},{"l":"Optional fields","p":["Fields with type option'T are represented as a field that may or may not be there. This is the case both for unions and records.","When parsing JSON, null is also accepted as a None value."]},{"l":"Constant cases","p":["Union cases annotated with the attribute [Constant c] are represented as the corresponding constant, which can be a string, int, float or bool. It is recommended to only use this attribute on argument-less cases. If all cases of a union are annotated with [Constant], then [NamedUnionCases] is not necessary."]},{"l":"Classes","p":["In order to be serializable to/from JSON on the server-side, a class must be annotated with the [System.Serializable] attribute and must have a default constructor. On the client-side, these are not checked or required. Then, it is serialized based on its fields, similarly to F# records as mentioned above. Here is an example in C#:"]},{"l":"DateTimes","p":["Values of type System.DateTime are encoded using an ISO 8601 round-trip format string:","The format can be customized with the [DateTimeFormat] attribute. This attribute can be placed either on a record field of type System.DateTime, or optionSystem.DateTime, or on a union case with an argument of one of these types.","Note, however, that [DateTimeFormat] is only available on the server side; this attribute is ignored by client-side serialization."]}],[{"l":"WebSharper UI","p":["WebSharper.UI is a library providing a novel, pragmatic and convenient approach to UI reactivity. It includes:","An HTML library usable both from the server side and from the client side, which you can use to build HTML pages either by calling F# functions to create elements, or by instantiating template HTML files.","A reactive layer for expressing user inputs and values computed from them as time-varying values. This approach is related to Functional Reactive Programming (FRP). This reactive system integrates with the HTML library to create reactive documents. If you are familiar with Facebook React, then you will find some similarities with this approach: instead of explicitly inserting, modifying and removing DOM nodes, you return a value that represents a DOM tree based on inputs. The main difference is that these inputs are nodes of the reactive system, rather than a single state value associated with the component.","Client-side routing using the same endpoint type declaration as WebSharper server-side routing.","This page is an overview of the capabilities of WebSharper.UI. You can also check the full reference of all the API types and modules.","Get the package from NuGet: WebSharper.UI."]},{"i":"where-is-it","l":"Where is it?","p":["NuGet package: WebSharper.UI","DLL: WebSharper.UI.dll","Namespace: WebSharper.UI"]},{"l":"HTML on the client","p":["To insert a Doc into the document on the client side, use the Doc.Run* family of functions from the module WebSharper.UI.Client. Each of these functions has two variants: one directly taking a DOM Element or Node, and the other suffixed with ById taking the id of an element as a string.","Doc.Run and Doc.RunById insert a given Doc as the child(ren) of a given DOM element. Note that it replaces the existing children, if any.","Doc.RunAppend and Doc.RunAppendById insert a given Doc as the last child(ren) of a given DOM element.","Doc.RunPrepend and Doc.RunPrependById insert a given Doc as the first child(ren) of a given DOM element.","Doc.RunAfter and Doc.RunAfterById insert a given Doc as the next sibling(s) of a given DOM node.","Doc.RunBefore and Doc.RunBeforeById insert a given Doc as the previous sibling(s) of a given DOM node.","Doc.RunReplace and Doc.RunReplaceById insert a given Doc replacing a given DOM node."]},{"l":"HTML on the server","p":["On the server side, using sitelets, you can create HTML pages from Docs by passing them to the Body or Head arguments of Content.Page.","By opening WebSharper.UI.Server, you can also just pass a full page to Content.Page. This is particularly useful together with templates.","To include client-side elements inside a page, use the client method, from inside WebSharper.UI.Html."]},{"i":"client-side-reactive-programming","l":"Client-side, reactive programming","p":["WebSharper.UI's reactive layer helps represent user inputs and other time-varying values, and define how they depend on one another.","Vars/Views/etc."]}],[{"l":"HTML","p":["Whether for your SPA or your client-server application, you will at some point undoubtedly be needing to work with HTML. To do so, you need to add WebSharper.UI to your project:","WebSharper.UI's core type for working with HTML is Doc. A Doc can represent a single DOM node (an element or plain text), or sequence of zero or more nodes.","Additionally, client-side Docs can be reactive. A same Doc can consist of different elements at different moments in time, depending on user input or other variables. See the reactive section to learn more about this.","There are three main types of uses for your HTML:","HTML sent from the server to fulfill an incoming request."]},{"l":"Docs"},{"i":"html-functions-aka-combinators","l":"HTML functions (aka. combinators)","p":["The main means of creating Docs is by using the functions in the WebSharper.UI.Html module. Every HTML element has a dedicated function, such as div or p, which takes a sequence of attributes(of type Attr) and a sequence of child nodes (of type Doc). Additionally, the text function creates a text node.","You may sometimes need stronger guarantees about Doc values, for instance, when there is a one-to-one correspondence to actual DOM nodes. To represent these \"actual\" HTML fragements, you can use Elt values.","which is a subtype of Doc that is guaranteed to always consist of exactly one element and provides additional APIs such as Dom to get the underlying Dom.Element. This subtyping means that you will sometimes need to upcast the result of such a function with : Doc to appease the compiler.","Some HTML tags, such as option, collide with standard library names and are therefore only located in the Tags submodule.","The following sections list some notable functions in Doc that you can use to create or combine Docs."]},{"i":"docempty","l":"Doc.Empty","p":["Creates a Doc consisting of zero nodes. This can be useful for example when you may not need to insert an element depending on a condition.","or:"]},{"i":"docappend","l":"Doc.Append","p":["Creates a Doc consisting of the concatenation of two Docs.","For the mathematically inclined, the functions Doc.Empty and Doc.Append make Docs a monoid."]},{"i":"docconcat","l":"Doc.Concat","p":["Generalizes Append by concatenating a sequence of Docs."]},{"i":"docelement","l":"Doc.Element","p":["Creates an element with the given name, attributes and children. It is equivalent to the function with the same name from the Html module. This function is useful if the tag name is only known at runtime, or if you want to create a non-standard element that isn't available in Html. The following example creates a header tag of a given level ( h1, h2, etc).","or","or etc."]},{"i":"docverbatim","l":"Doc.Verbatim","p":["Creates a Doc from plain HTML text.","This function does not perform any checks on the contents, and can be a code injection vulnerability if used improperly. We recommend avoiding it unless absolutely necessary, and properly sanitizing user inputs if you do use it. If you simply want to use HTML syntax instead of F# functions, take a look at templating."]},{"l":"Attrs","p":["To create attributes, use corresponding functions from the attr submodule.","Some attributes, notably class and type, are also F# keywords, so they need to be wrapped in double backquotes.","HTML5 also defines any attribute whose names starts with data- as a valid custom attribute. You can create such an attribute using the function data- from module attr(backquoted since it contains a non-standard character).","Like Doc, a value of type Attr can represent zero, one or more attributes. The functions in the Attr module can create such non-singleton attributes."]},{"i":"attrempty","l":"Attr.Empty","p":["Creates an empty attribute. This can be useful for example when you may not need to insert an attribute depending on a condition.","or"]},{"i":"attrappend","l":"Attr.Append","p":["Combines two attributes."]},{"i":"attrconcat","l":"Attr.Concat","p":["Combines a sequence of attributes."]},{"i":"attrcreate","l":"Attr.Create","p":["Creates a single attribute. It is equivalent to the function with the same name from the attr module. This function is useful if the attribute name is only known at runtime, or if you want to create a non-standard attribute that isn't available in attr."]},{"l":"Event handlers","p":["Event handlers can be added using the functions from the on submodule.","The handler function takes two arguments:","The element itself on which the event was raised, as a native Dom.Element, and","The event arguments, as a subtype of the native Dom.Event.","In addition to the standard HTML events, on.afterRender is a special handler that is called by WebSharper after inserting the element into the DOM."]}],[{"l":"HTML templates","p":["WebSharper.UI's syntax for creating HTML is compact and convenient, but sometimes you do need to include a plain HTML file in a project. It is much more convenient for designing to have a .html file that you can touch up and reload your application without having to recompile it. This is what Templates provide. Templates are HTML files that can be loaded by WebSharper.UI, and augmented with special elements and attributes that provide additional functionality:","Declaring Holes for nodes, attributes and event handlers that can be filled at runtime by F# code;","Declaring two-way binding between F# Vars and HTML input elements (see reactive);","Declaring inner Templates, smaller HTML widgets within the page, that can be instantiated dynamically.","All of these are parsed from HTML at compile time and provided as F# types and methods, ensuring that your templates are correct."]},{"l":"Basics","p":["To declare a template, use the Template type provider from the namespace WebSharper.UI.Templating.","To instantiate it, call your type's constructor and then its .Doc() method.","my-template.html:","equivalent to:","Note that the template doesn't have to be a full HTML document, but can simply be a snippet or sequence of snippets. This is particularly useful to build a library of widgets using inner templates.","If the template comprises a single HTML element, then an additional method .Elt() is available. It is identical to .Doc(), except its return value has type Elt instead of Doc.","You can also declare a template from multiple files at once using a comma-separated list of file names. In this case, the template for each file is a nested class named after the file, truncated of its file extension.","second-template.html:"]},{"l":"Holes","p":["${HoleName} creates a string hole. You can use it in text or in the value of an attribute.","Event: Dom.Event is the event triggered.","If you don't fill the hole (ie you don't call .Name(varName) above), the Var will be implicitly created, so ${Name} will still be dynamically updated from the user's input.","input type=checkbox, for which it creates a Varbool hole.","input type=number, for which it creates a hole that can be one of the following types: Varint, Varfloat, VarCheckedInputint, VarCheckedInputfloat.","input, textarea, select, for which it creates a Varstring hole.","my-template.html:","On the client side, this hole can also be filled with a Viewstring(see reactive) to include dynamically updated text content.","Result:","Target: Dom.Element is the element itself.","The attribute ws-attr creates an Attr or seqAttr hole. The name of the hole is the value of the ws-attr attribute.","The attribute ws-hole creates a Doc or seqDoc hole. The element on which this attribute is set will have its contents replaced with the provided Doc(s). The name of the hole is the value of the ws-hole attribute.","The attribute ws-onclick(or any other event name instead of click) creates an event handler hole of type TemplateEvent - unit. The argument of type TemplateEvent has the following fields:","The attribute ws-replace creates a Doc or seqDoc hole. The element on which this attribute is set will be replaced with the provided Doc(s). The name of the hole is the value of the ws-replace attribute.","The attribute ws-var creates a Var hole (see reactive) that is bound to the element. It can be used on the following elements:","The name of the hole is the value of the ws-var attribute. Text ${Hole} s with the same name can be used, and they will dynamically match the value of the Var.","Vars has a field for each of the Var s associated to ws-var s in the template.","You can add holes to your template that will be filled by F# code. Each hole has a name. To fill a hole in F#, call the method with this name on the template instance before finishing with .Doc()."]},{"l":"Filling holes","p":["There are two ways to fill the content for a given hole.","The recommended way is by using the method with the hole's name on the template instance, as used in the examples above.","If you need to decide which hole to fill at runtime, you can use the method .With(holeName, content). It will throw a runtime error if the content's type doesn't match the hole's type.","You can of course mix and match both styles."]},{"l":"Inner templates","p":["To create a template for a widget (as opposed to a full page), you can put it in its own dedicated template file, but another option is to make it an inner template. An inner template is a smaller template declared inside a template file using the following syntax:","The ws-template attribute declares that its element is a template whose name is the value of this attribute.","The ws-children-template attribute declares that the children of its element is a template whose name is the value of this attribute.","Inner templates are available in F# as a nested class under the main provided type.","my-template.html:","Result:"]},{"l":"Instantiating templates in HTML","p":["You can also instantiate a template within another template, entirely in HTML, without the need for F# to glue them together.","A node named ws-TemplateName instantiates the inner template TemplateName from the same file. A node named ws-fileName.TemplateName instantiates the inner template TemplateName from the file fileName. The file name is the same as the generated class name, so with file extension excluded.","Child elements of the ws-* fill holes. These elements are named after the hole they fill.","${Text} holes are filled with the text content of the element.","ws-hole and ws-replace holes are filled with the HTML content of the element.","ws-attr holes are filled with the attributes of the element.","Other types of holes cannot be directly filled like this.","Additionally, attributes on the ws-* element itself define hole mappings. That is to say, ws-MyTpl Inner=Outer fills the hole named Inner of the template MyTpl with the value of the hole Outer of the containing template. As a shorthand, ws-MyTpl Attr is equivalent to ws-MyTpl Attr=Attr.","Any holes that are neither mapped by an attribute nor filled by a child element are left empty.","The following example is equivalent to the example from Inner Templates:","my-template.html:"]},{"l":"Controlling the loading of templates","p":["The type provider can be parameterized to control how its contents are loaded both on the server and the client. For example:","The possible values for clientLoad are:","ClientLoad.Inline(default): The template is included in the compiled JavaScript code, and any change to my-template.html requires a recompilation to be reflected in the application.","ClientLoad.FromDocument: The template is loaded from the DOM. This means that my-template.html must be the document in which the code is run: either directly served as a Single-Page Application, or passed to Content.Page in a Client-Server Application.","In this mode, it doesn't make sense for client-side code to instantiate the full template, since you are already inside the document. But the following are possible:","Instantiating inner templates.","Binding directly to the DOM.","The possible values for serverLoad are:","ServerLoad.WhenChanged(default): The runtime sets up a file watcher on the template file, and reloads it whenever it is edited.","ServerLoad.Once: The template file is loaded on first use and never reloaded.","ServerLoad.PerRequest: The template file is reloaded every time it is needed. We recommend against this option for performance reasons."]},{"l":"Binding directly to the DOM","p":["When using a template from the client side that is declared with clientLoad = ClientLoad.FromDocument, you can directly bind content, Vars, etc. to the DOM. Instead of calling .Doc() to create a Doc, use .Bind(), which returns unit, to just apply the template to the current document.","index.html:","Result:","Note that for Bind() to work correctly, the holes need to be present in the document itself. This is not a problem if your project is an SPA. But you can also serve the page from a Sitelet, using the same template on the server side. You can fill some holes on the server side and leave some to be filled by the client side. However, by default, the server-side engine removes unfilled holes from the served document. This is correct behavior in most cases, but here, the client does need the unfilled hole markers like ws-replace or ${...} to be present. So this behavior can be overridden by the optional boolean argument keepUnfilled of the .Doc() and .Elt() methods.","Served page:","Result after Client.Startup() has run:"]},{"i":"accessing-the-templates-model","l":"Accessing the template's model","p":["Templates allow you to access their \"model\", ie the set of all the reactive Var s that are bound to it, whether passed explicitly or automatically created for its ws-var s. It is accessible in two ways:","In event handlers, it is available as the Vars property of the handler argument.","From outside the template: instead of finishing the instanciation of a template with .Doc(), you can call .Create(). This will return a TemplateInstance with two properties: Doc, which returns the template itself, and Vars, which contains the Vars. This method is only available when instantiating the template from the client side.","my-template.html:","Result:"]},{"l":"Mixing client code in server-side templates","p":["It is possible to include some client-side functionality when creating a template on the server side.","If you use ws-var=VarName, the corresponding Var will be created on the client on page startup. However, passing a Var using .VarName(myVar) is not possible, since it would be a server-side Var.","Event handlers (such as ws-onclick=EventName) work fully if you pass an anonymous function: .EventName(fun e - ...). The body of this function will be compiled to JavaScript. You can also pass a top-level function, in this case it must be declared with [JavaScript].","This also includes ws-onafterrender, which causes the given function to be called on page startup."]},{"l":"Special holes in server-side templates","p":["In a server-side template, you must specify the location of where WebSharper can include its generated content. Three special placeholders are provided to include client-side content in the page:","scripts is replaced with the JavaScript files required by the client-side code included in the page (including WebSharper-generated .js files). Usage: script ws-replace=scripts/script","styles is replaced with the CSS files required by the client-side code included in the page. Usage: link ws-replace=styles /","meta is replaced with a meta tag that contains initialization data for client-side controls. Usage: meta ws-replace=meta /","The scripts hole is necessary for correct working of the served page if it contains any client-side WebSharper functionality. The other two are optional: if neither styles nor meta is provided explicilty, then they are included automatically above the content for scripts."]},{"l":"Dynamic templates","p":["It is also possible to create a template without the compile-time safety of the type provider. This is done using the type DynamicTemplate.","This type can be used similarly to Template..., with the following limitations:","It is server-side only.","Its constructor must receive the HTML source as a string.","Holes can only be filled with .With(holeName, content).","The final instantiation must be done with .Doc()."]}],[{"l":"Reactive vars","p":["Reactive values that are directly set by code or by user interaction are represented by values of type Var'T. Vars are similar to F# ref'T in that they store a value of type 'T that you can get or set using the Value property. But they can additionally be reactively observed or two-way bound to HTML input elements.","The following UI helpers are from WebSharper.UI.Client, for more variants check the Doc module."]},{"i":"docinput","l":"Doc.Input","p":["Creates an input element with given attributes that is bound to a Varstring.","With the above code, once myInput has been inserted in the document, varText.Value yields what the user has entered, and setting it updates the value of the input control."]},{"i":"docintinput-and-docfloatinput","l":"Doc.IntInput and Doc.FloatInput","p":["Creates an input type=number bound to a VarCheckedInput_ of the corresponding type ( int or float, respectively). CheckedInput provides access to the validity and actual user input, and it is defined as follows:","CheckedInput.Invalid is returned when the input can not be parsed into a number."]},{"i":"docintinputunchecked-and-docfloatinputunchecked","l":"Doc.IntInputUnchecked and Doc.FloatInputUnchecked","p":["Creates an input type=number bound to a Var_ of the corresponding type ( int or float, respectively). These functions do not check for the validity of the user's input, so be sure to only rely on them in situations where this is acceptable. Otherwise, use Doc.IntInput or Doc.FloatInput instead."]},{"i":"docinputarea","l":"Doc.InputArea","p":["Creates a textarea element bound to a Varstring."]},{"i":"docpasswordbox","l":"Doc.PasswordBox","p":["Creates an input type=password element bound to a Varstring."]},{"i":"doccheckbox","l":"Doc.CheckBox","p":["Creates an input type=checkbox element bound to a Varbool."]},{"i":"doccheckboxgroup","l":"Doc.CheckBoxGroup","p":["Creates an input type=checkbox, but instead of associating it with a simple Varbool, it associates it with a specific 'T in a Varlist'T. If the box is checked, then the element is added to the list, otherwise it is removed.","varColor is bound to the list of ticked checkboxes."]},{"i":"docselect","l":"Doc.Select","p":["Creates a select dropdown given a list of values to select from. The label of every option is determined by the given print function for the associated value.","varColor is bound to contain the selected color."]},{"i":"docradio","l":"Doc.Radio","p":["Creates an input type=radio given a value, which sets the given Var to that value when it is selected.","varColor is bound to contain the selected color."]}],[{"l":"Reactive views","p":["The full power of WebSharper.UI's reactive layer comes from using View values. A View'T is a time-varying value computed from any number of Vars and other Views, and its value automatically changes (if read programmatically or bound on the UI, see below) each time any of those dependencies change.","One important property to remember is that the value of a View is not computed unless it is needed. For example, if you use View.Map, the function passed to it will only be called if the result is needed. It will only be run while the resulting View is included in the document using one of these methods. This means that you generally don't have to worry about expensive computations being performed unnecessarily. However it also means that you should avoid relying on side-effects performed in functions like View.Map.","Note that several of the functions below can be used more concisely using the V shorthand."]},{"l":"Creating and combining Views","p":["The first and main way to get a View is using the View property of Var'T. This retrieves a View that tracks the current value of the Var.","You can create Views using the following functions and combinators from the View module:"]},{"i":"viewconst","l":"View.Const","p":["Creates a View whose value is always the same."]},{"i":"viewconstanyc","l":"View.ConstAnyc","p":["Similar to View.Const, but is initialized asynchronously. Until the async returns, the resulting View is uninitialized."]},{"i":"viewmap","l":"View.Map","p":["Takes an existing View and maps its value through a function."]},{"i":"viewmap2","l":"View.Map2","p":["Takes two existing Views and map their value through a function.","Similarly, View.Map3 takes three existing Views and map their value through a function."]},{"i":"viewmapasync","l":"View.MapAsync","p":["Similar to View.Map, but maps through an asynchronous function.","An important property here is that this combinator saves work by abandoning requests. That is, if the input view changes faster than we can asynchronously convert it, the output view will not propagate change until it obtains a valid latest value. In such a system, intermediate results are thus discarded.","Similarly, View.MapAsync2 maps two existing Views through an asynchronous function."]},{"i":"viewapply","l":"View.Apply","p":["Takes a View of a function and a View of its argument type, and combines them to create a View of its return type.","While Views of functions may seem like a rare occurrence, they are actually useful together with View.Const in a pattern that can lift a function of any number N of arguments into an equivalent of View.Map N."]},{"l":"Inserting Views in Docs","p":["Once you have created a View to represent your dynamic content, here are the various ways to include it in a Doc:"]},{"l":"textView","p":["Is a reactive counterpart to text, which creates a text node from a Viewstring."]},{"i":"docbindview","l":"Doc.BindView","p":["Maps a View into a dynamic Doc."]},{"i":"docembedview","l":"Doc.EmbedView","p":["Unwraps a ViewDoc into a Doc. It is equivalent to Doc.BindView id."]},{"i":"attrdyn","l":"attr.*Dyn","p":["The reactive equivalent to the corresponding attr.* functions, creating an attribute from a Viewstring.","For example, the following sets the background of the input element based on the user input value:"]},{"i":"attrdynpred","l":"attr.*DynPred","p":["Similar to the attr.*Dyn family of funtions, but takeing an extra Viewbool. When this View is true, the attribute is set (and dynamically updated as with attr.*Dyn), and when it is false, the attribute is removed."]},{"l":"Mapping Views on sequences","p":["Applications often deal with varying collections of data. This means using a View of a sequence: a value of type ViewseqT, ViewlistT or ViewT[]. In this situation, it can be sub-optimal to use Map or Doc to render it: the whole sequence will be re-computed even when a single item has changed.","The SeqCached family of functions fixes this issue. These functions map a View of a sequence to either a new ViewseqU(functions View.MapSeqCached* and method .MapSeqCached()) or to a Doc(functions Doc.BindSeqCached and method .DocSeqCached()) but avoid re-mapping items that haven't changed.","There are different versions of these functions, which differ in how they decide that an item \"hasn't changed\"."]},{"i":"viewmapseqcached","l":"View.MapSeqCached","p":["View.MapSeqCached : ('T - 'V) - Viewseq'T - Viewseq'V uses standard F# equality to check items."]},{"i":"viewmapseqcachedby","l":"View.MapSeqCachedBy","p":["View.MapSeqCachedBy : ('T - 'K) - ('T - 'V) - Viewseq'T - Viewseq'V uses the given key function to check items. This means that if an item is added whose key is already present, the corresponding returned item is not changed. So you should only use this when items are intended to be added or removed, but not changed."]},{"i":"viewmapseqcachedviewby","l":"View.MapSeqCachedViewBy","p":["View.MapSeqCachedViewBy : ('T - 'K) - ('K - View'T - 'V) - Viewseq'V covers the situation where items are identified by a key function and can be updated. Instead of passing the item's value to the mapping function, it passes a View of it, so you can react to the changes.","Each of these View.MapSeqCached* functions has a corresponding Doc.BindSeqCached*:","Doc.BindSeqCached : ('T - #Doc) - Viewseq'T - Doc","Doc.BindSeqCachedBy : ('T - 'K) - ('T - #Doc) - Viewseq'T - Doc","Doc.BindSeqCachedViewBy : ('T - 'K) - ('K - View'T - #Doc) - Viewseq'T - Doc","These functions map each item of the sequence to a Doc and then concatenate them. They are basically equivalent to passing the result of the corresponding View.MapSeqCached* to Doc.BindView Doc.Concat, the same way the examples above did.","Finally, all of the above functions are also available as extension methods on the Viewseq'T type.",".MapSeqCached() overloads correspond to View.MapSeqCached* functions, and",".DocSeqCached() overloads correspond to Doc.BindSeqCached* functions."]}],[{"l":"Lenses"},{"l":"Vars and lensing","p":["The Var'T type is actually an abstract class, this makes it possible to create instances with an implementation different from Var.Create. The main example of this are lenses.","In WebSharper.UI, a lens is a Var without its own storage cell that \"focuses\" on a sub-part of an existing Var. For example, given the following:","You might want to create a form that allows entering the first and last name separately. For this, you need two Varstring s that directly observe and alter the FirstName and LastName fields of the value stored in varPerson. This is exactly what a lens does.","To create a lens, you need to pass a getter and a setter function. The getter is called when the lens needs to know its current value, and extracts it from the parent Var's current value. The setter is called when setting the value of the lens; it receives the current value of the parent Var and the new value of the lens, and returns the new value of the parent Var."]},{"l":"Automatic lenses","p":["In the specific case of records, you can use LensAuto to create lenses more concisely. This method only takes the getter, and is able to generate the corresponding setter during compilation.","You can be even more concise when using the Doc.Input family of functions, thanks to the V shorthand."]},{"l":"The V shorthand","p":["Mapping reactive values from their model to a value that you want to display can be greatly simplified using the V shorthand. This shorthand revolves around passing calls to the property view.V to a number of supporting functions."]},{"l":"Views and V","p":["When an expression containing a call to view.V is passed as argument to one of the supporting functions, it is converted to a call to View.Map on this view, and the resulting expression is used in a way relevant to the supporting function.","The simplest supporting function is called V, and it simply returns the view expression.","You can use arbitrarily complex expressions:","Other supporting functions use the resulting View in different ways:","text passes the resulting View to textView.","attr.* attribute creation functions pass the resulting View to the corresponding attr.*Dyn.","Attr.Style passes the resulting View to Attr.DynamicStyle.","Calling .V outside of one of the above supporting functions is a compile error. There is one exception: if view is a ViewDoc, then view.V is equivalent to Doc.EmbedView view."]},{"l":"Vars and V","p":["Vars also have a .V property. When used with one of the above supporting functions, it is equivalent to .View.V.","Additionally, var.V can be used as a shorthand for lenses. .V is a shorthand for .LensAuto when passed to the following supporting functions:","Lens simply creates a lensed Var.","Doc.InputV","Doc.InputAreaV","Doc.PasswordBoxV","Doc.IntInputV, Doc.IntInputUncheckedV","Doc.FloatInputV, Doc.FloatInputUncheckedV"]}],[{"l":"ListModels","p":["ListModel'K, 'T is a convenient type to store an observable collection of items of type 'T. Items can be accessed using an identifier, or key, of type 'K.","ListModels are to dictionaries as Vars are to refs: a type with similar capabilities, but with the additional capability to be reactively observed, and therefore to have your UI automatically change according to changes in the stored content."]},{"l":"Creating ListModels","p":["You can create ListModels with the following functions:"]},{"i":"listmodelfromseq","l":"ListModel.FromSeq","p":["Creates a ListModel where items are their own key."]},{"i":"listmodelcreate","l":"ListModel.Create","p":["Creates a ListModel using a given function to determine the key of an item.","(The examples on this page use the above Person type and myPeople model.)"]},{"l":"Modifying ListModels","p":["Once you have a ListModel, you can modify its contents in a number of ways, see below."]},{"i":"listmodeladd","l":"listModel.Add","p":["Inserts an item into the model. If there is already an item with the same key, this item is replaced."]},{"i":"listmodelremovebykey","l":"listModel.RemoveByKey","p":["Removes the item from the model that has the given key. If there is no such item, then nothing happens."]},{"i":"listmodelremove","l":"listModel.Remove","p":["Removes the item from the model that has the same key as the given item. It is effectively equivalent to listModel.RemoveByKey(getKey x), where getKey is the key function passed to ListModel.Create and x is the argument to Remove."]},{"i":"listmodelset","l":"listModel.Set","p":["Sets the entire contents of the model, discarding the previous contents."]},{"i":"listmodelclear","l":"listModel.Clear","p":["Removes all items from the model."]},{"i":"listmodelupdateby","l":"listModel.UpdateBy","p":["Updates the item with the given key. If the function returns None or the item is not found, nothing is done."]},{"i":"listmodelupdateall","l":"listModel.UpdateAll","p":["Updates all the items of the model. If the function returns None, the corresponding item is unchanged."]},{"i":"listmodellens","l":"listModel.Lens","p":["Creates an Var'T that does not have its own separate storage, but is bound to the value for a given key."]},{"i":"listmodellensinto","l":"listModel.LensInto","p":["Creates an Var'T that does not have its own separate storage, but is bound to a part of the value for a given key."]},{"l":"Reactively observing ListModels","p":["The main purpose for using a ListModel is to be able to reactively observe it."]},{"i":"listmodelview","l":"listModel.View","p":["Gives a Viewseq'T that reacts to changes to the model.","The following example creates an HTML list of people which is automatically updated based on the contents of the model."]},{"i":"listmodelviewstate","l":"listModel.ViewState","p":["Is equivalent to View, except that it returns a ViewListModelState'T. Here are the differences:","ViewState provides better performance.","ListModelState'T implements seq'T, but it additionally provides indexing and length of the sequence.","However, a ViewState is only valid until the next change to the model.","As a summary, it is generally better to use ViewState. You only need to choose View if you need to store the resulting seq separately."]},{"i":"listmodelmap","l":"listModel.Map","p":["Reactively maps a function on each item. It is similar to the View.MapSeqCached family of functions: it is optimized so that the mapping function is not called again on every item when the content changes, but only on changed items. There are two variants:"]},{"i":"mapf-t---v","l":"Map(f: 'T -> 'V)","p":["Assumes that the item with a given key does not change. It is equivalent to View.MapSeqCachedBy using the ListModel's key function."]},{"i":"mapf-k---viewt---v","l":"Map(f: 'K -> View<'T> -> 'V)","p":["Additionally observes changes to individual items that are updated. It is equivalent to View.MapSeqCachedViewBy using the ListModel's key function.","Note that in both cases, only the current state is kept in memory: if you remove an item and insert it again, the function will be called again."]},{"i":"listmodelmaplens","l":"listModel.MapLens","p":["Is similar to the second Map method above, except that it passes an Var'T instead of a View'T. This makes it possible to edit list items within the mapping function."]},{"i":"listmodeldoc","l":"listModel.Doc","p":["Is similar to Map, but the function must return a Doc and the resulting Docs are concatenated. It is similar to the Doc.BindSeqCached family of functions."]},{"i":"listmodeldoclens","l":"listModel.DocLens","p":["Like MapLens but concatenating the resulting Docs."]},{"i":"listmodeltryfindbykeyasview","l":"listModel.TryFindByKeyAsView","p":["Gives a View on the item that has the given key, or None if it is absent."]},{"i":"listmodelfindbykeyasview","l":"listModel.FindByKeyAsView","p":["Is equivalent to TryFindByKeyAsView, except that when there is no item with the given key, an exception is thrown."]},{"i":"listmodelcontainskeyasview","l":"listModel.ContainsKeyAsView","p":["Gives a View on whether there is an item with the given key. It is equivalent to (but more optimized than):"]}],[{"l":"Routing","p":["If you have a WebSharper.Sitelets.Router'T value, it can be shared between server and client. A router encapsulates two things: parsing an URL path to an abstract value and writing a value as an URL fragment. So this allows generating links safely on both client When initializing a page client-side, you can decide to install a custom click handler for your page which recognizes some or all local links to handle without browser navigation."]},{"l":"Install client-side routing","p":["There are 3 scenarios for client-side routing which WebSharper routing makes possible:","For creating single-page applications, when browser refresh is never wanted, Router.Install creates a global click handler that prevents default behavior of a links on your page pointing to a local URL.","If you want client-side navigation only between some part of the whole site map covered by the router, you can use Router.Slice before Router.Install. This creates a global click handler that now only override behavior of local links which can be mapped to the subset of endpoints that are handled in the client. For example you can make navigating between yoursite.com/profile/... links happen with client-side routing, but any links that would point out of /profile/... are still doing browser navigation automatically.","If you want to have client-side routing on a sub-page that the server knows nothing about, Router.InstallHash subscribes to window.location.hash changes only. You can use a router that is specific to that single sub-page.","In all cases, the Install function used returns a Var, which you can use to map the visible content of your page from. It has a two way binding to the URL: link or forward/back navigation changes the value of the Var, and setting the value does a client-side navigation which also updates the URL automatically.","Example for Router.Install, using the router value introduced in the Sitelets documentation:","First argument ( Home) specifies which page value to fall back on if the URL path cannot be parsed (although this won't happen if you set up your server-side correctly), which could be a home or an error page.","Also, you need to make sure that your router value is [JavaScript] annotated (or a containing type, module or the assembly is), so that it is available for cross-tier use.","Router.InstallHash have the same signature as Router.Install, the only difference is that URLs would look like yoursite.com/#/contact/Bob/32.","Example for Router.Slice and Router.Install:","Here we only install a click handler for the contact pages, which means that a link to root will be a browser navigation, but links between contacts work fully on the client. The first function argument maps a full page value to an option of a value that we handle, and the second function maps this back to a full page value. So instead of a VarPages here we get only a VarPerson.","In a real world application, usually you would have some View.MapAsync from the location variable, to pull some data related to the subpage from the server by an RPC call, and exposing that as content:","You can navigate programmatically with location.Value - newLoc, location | Var.Set newLoc or location := newLoc(if you have open WebSharper.UI.Next.Notation)."]}],[{"i":"unit-testing-with-websharpertesting","l":"Unit testing with WebSharper.Testing","p":["WebSharper.Testing provides an easy-to-use, concise syntax for writing unit tests for libraries, services and web applications. It's a wrapper around QUnit, which handles synchronous and asynchronous expressions and generates random data for property testing. The main tests page is meant to be run in a browser, but server-sides can also be tested by making remote calls from the tests.","The code samples below assume that the module or assembly containing them is annotated with [JavaScript], except when they refer to server-side code."]},{"i":"where-is-it","l":"Where is it?","p":["NuGet package: WebSharper.Testing","DLL: WebSharper.Testing.dll","Namespace: WebSharper.Testing"]},{"l":"Test categories and tests"},{"l":"TestCategory","p":["Creates a definition for a single named test category. You can think of it as similar to F#'s lazy keyword: the code inside is not executed immediately, but only when it is passed to Runner.RunTests."]},{"l":"Test","p":["Creates a definition for a single named test. Similarly to TestCategory, it delays the execution of its content and registers it in QUnit.","Test name is a computation expression (CE) builder that defines various custom operations (such as equal, notEqual, etc.) to use for individual assertions."]},{"i":"runnerruntests","l":"Runner.RunTests","p":["Takes an array of TestCategory values, and returns an IControlBody, which can be used inside the client @ ... @ helper to serve a page that runs the given tests. You can also call its ReplaceInDom method directly on the client, to replace a placeholder DOM element with the content generated by QUnit.","Later, in your server-side code, you can serve this on a sitelet endpoint:"]},{"l":"Expect","p":["Tells the testing framework how many test cases are expected to be registered for a given category. If a category registers no tests, QUnit reports it as a failure, unless you add expect 0."]},{"l":"Assertions","p":["Most assertions have three additional variants:","xxxMsg- takes an additional name argument for its assertion,","xxxAsync- takes a value of type Async'T instead of the actual value 'T. Expected value is still provided as a value of 'T.","xxxMsgAsync- the combination of the above."]},{"l":"isTrue","p":["Checks if a single argument expression evaluates to true."]},{"l":"isFalse","p":["The negation of isTrue: the test passes if the expression evaluates to false."]},{"l":"Equality checks"},{"l":"equal","p":["Checks if two expressions evaluate to equal values when tested with WebSharper's equality semantics. This is the same as using the = operator from F# code, unions and records have structural equality and overrides on the Equals method or implementing IEquatable are honored."]},{"l":"notEqual","p":["The negation of equal: fails if two values are equal with respect to WebSharper's equality."]},{"l":"jsEqual","p":["Checks if two expressions evaluate to equal values when tested with JavaScript's == operator. This is the same as using the ==. operator in F# code (available with open WebSharper.JavaScript)."]},{"l":"notJsEqual","p":["The negation of jsEqual: fails if two values are equal with JavaScript's == operator."]},{"l":"strictEqual","p":["Checks if two expressions evaluate to equal values when tested with JavaScript's === operator. This is the same as using the ===. operator in F# code (available with open WebSharper.JavaScript)."]},{"l":"notStrictEqual","p":["The negation of strictEqual: fails if two values are equal with JavaScript's === operator."]},{"l":"deepEqual","p":["Checks if two expressions evaluate to equal values when tested with QUnit's deepEqual function. This uses a deep recursive comparison, working on primitive types, arrays, objects, regular expressions, dates and functions."]},{"l":"notDeepEqual","p":["The negation of deepEqual: fails if two values are equal using QUnit's notDeepEqual function."]},{"l":"propEqual","p":["Checks if two expressions evaluate to equal values when tested with QUnit's propEqual function. This function compares only the direct properties on an object with strict equality (===)."]},{"l":"notPropEqual","p":["The negation of propEqual: fails if two values are equal using QUnit's notPropEqual function."]},{"l":"approxEqual","p":["Compares floating point numbers, where a difference/epsilon of 0.0001 is accepted."]},{"l":"notApproxEqual","p":["The negation of approxEqual: fails if the difference of two values is 0.0001."]},{"l":"Exception testing"},{"l":"raises","p":["Checks that an expression is raising any exceptions, and passes test if it does. Note that the arguments are always implicitly enclosed within a lambda function by the framework, making sure that they are only evaluated when the test is running."]},{"l":"Asynchronous tests","p":["Test computation expressions also allow binding an async workflow at any point. If this is not used, and all assertions are synchronous then the entire test case will run synchronously for optimal performance."]},{"l":"Property testing"},{"l":"Do","p":["Using Do is very similar to using Test name: it is a computation expression builder, enabling the same custom operations. The difference is that it is not named, and also by itself does not register tests, as its intended use is to create sub-tests that can be executed inside a named test when doing property testing."]},{"l":"property","p":["Auto-generates 100 random values based on a type and runs a sub-test with all of them. Supported types are int, float, bool, string, unit, obj, and also tuples, lists, arrays, options, seq, and ResizeArray composed from these. Using the obj type results in values from a mix of various types. When using a non-supported type, it results in a compile-time error."]},{"l":"propertyWith","p":["Similar to property, but the generator logic is not inferred from a type, but instead is passed as an RandomValues.Generator argument, which is described later on this page.","There are also constructors and combinators in the Random module to get Generator values, allowing easier composition of complex test data."]},{"l":"propertyWithSample","p":["Similar to propertyWith, but the argument is an exact sample on which the property is tested. See RandomValues.Sample below."]},{"l":"Looping"},{"l":"forEach","p":["You cannot use a regular for loop inside a Test computation expression, but you can emulate it with the forEach operation. Its use is similar to property testing, and you can use Do to define the body of the loop."]},{"l":"Sample generators"},{"i":"randomvaluesgenerator","l":"RandomValues.Generator","p":["A generator is a record that can hold an array of static values to always test against, and a function that can return additional values to be tested dynamically. It is defined as follows:"]},{"i":"randomvaluessample","l":"RandomValues.Sample","p":["The RandomValues.Sample type is a thin wrapper around an array of values, exposing multiple constructors to create from a given array or explicit or inferred generators.","Examples:"]},{"l":"Random generator constructors","p":["The following produce simple RandomValues.Generator values:","RandomValues.StandardUniform: Standard uniform distribution sampler.","RandomValues.Exponential: Exponential distribution sampler.","RandomValues.Boolean: Generates random booleans.","RandomValues.Float: Generates random doubles.","RandomValues.FloatExhaustive: Generates random doubles, including corner cases (NaN, Infinity).","RandomValues.Int: Generates random int values.","RandomValues.Natural: Generates random natural numbers (0, 1, ...).","RandomValues.Within low hi: Generates integers within a range.","RandomValues.FloatWithin low hi: Generates doubles within a range.","RandomValues.String: Generates random strings.","RandomValues.ReadableString: Generates random readable strings.","RandomValues.StringExhaustive: Generates random strings including nulls.","RandomValues.Auto'T: Auto-generate values based on type, same as what property uses internally.","RandomValues.Anything: Generates a mix of ints, floats, bools, strings and tuples, lists, arrays, options of these."]},{"l":"Random generator combinators","p":["RandomValues.Map mapping gen: Maps a function over a generator.","RandomValues.SuchThat predicate gen: Filters the values of a generator by a predicate.","RandomValues.ArrayOf gen: Generates arrays (up to lengh 100), getting the items from the given generator.","RandomValues.ResizeArrayOf gen: Generates ResizeArray s.","RandomValues.ListOf gen: Generates List s.","RandomValues.Tuple2Of (a, b): Generates a 2-tuple, getting the items from the given generators.","RandomValues.Tuple3Of (a, b, c): Same as above for 3-tuples.","RandomValues.Tuple4Of (a, b, c, d): Same as above for 4-tuples.","RandomValues.OneOf arr: Generates values from a given array.","RandomValues.Mix a b: Mixes values coming from two generators, alternating between them.","RandomValues.MixMany gens: Mixes values coming from an array of generators.","RandomValues.MixManyWithoutBases gens: Same as above, but skips the constant base values.","RandomValues.Const x: Creates a generator that always returns the same value.","RandomValues.OptionOf x: Creates a generator has None as a base value, then maps items using Some."]}]]